\documentclass[sigplan,screen,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

% TODO: take a look into the program in which all the 250 sequences were better.

\bibliographystyle{ACM-Reference-Format}

% \citestyle{acmauthoryear}   %% For author/year citations

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{lineno}
\usepackage{url}
\usepackage{soul}
\usepackage{microtype}

\def\qed{\unskip\kern 10pt{\unitlength1pt\linethickness{.4pt}\framebox(6,6){}}}

\newcommand{\Hapi}{\mbox{\textsc{Hapi}}}

\setlength{\belowcaptionskip}{-7pt}

\soulregister\cite7

\newcommand{\fer}[1]{\textcolor{green}{#1}}
\newcommand{\vin}[1]{\textcolor{blue}{#1}}
\newcommand{\alx}[1]{\textcolor{red}{#1}}


\begin{document}

\title[Hapi: A Domain Specific Language for the Specification of Access Policies]
{Hapi: A Domain Specific Language for the Specification of Access Policies}
% \subtitle{Subtitle Text, if any}

\author{Vin\'{i}cius Juli\~{a}o}
\orcid{0000-0002-8588-8197}
\affiliation{
  \institution{UFMG}
  \streetaddress{Avenida Antônio Carlos, 6627}
  \city{Belo Horizonte}
  \state{Minas Gerais}
  \postcode{31.270-213}
  \country{Brazil}
}
\email{vinicius@dcc.ufmg.br.br}

\author{Alexander Holmquist}
\orcid{0000-0002-8588-8197}
\affiliation{
  \institution{UFMG}
  \streetaddress{Avenida Antônio Carlos, 6627}
  \city{Belo Horizonte}
  \state{Minas Gerais}
  \postcode{31.270-213}
  \country{Brazil}
}
\email{alexander@dcc.ufmg.br.br}

\author{Fernando M. Quint\~{a}o Pereira}
\orcid{nnnn-nnnn-nnnn-nnnn}
\affiliation{
%  \department{DCC}
  \institution{UFMG}
  \streetaddress{Avenida Antônio Carlos, 6627}
  \city{Belo Horizonte}
%  \state{Minas Gerais}
  \postcode{31.270-213}
  \country{Brazil}
}
\email{fernando@dcc.ufmg.br}

%\thanks{Thank people here}                %% \thanks is optional

\begin{abstract}
Hapi (short for Hierarchical Access Policy Implementation), is a specification
language that lets users define access policies.
In a distributed system, an access policy defines the actions that each actor
can perform on the available resources. 
Such policies are important because they ensure the preservation of the
integrity and the privacy of personal information that users might store
into remotely accessed databases.

\fer{Finish the abstract.}
\end{abstract}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
 <ccs2012>
 <concept>
 <concept_id>10011007.10011006.10011041.10011048</concept_id>
 <concept_desc>Software and its engineering~Runtime environments</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011041</concept_id>
 <concept_desc>Software and its engineering~Compilers</concept_desc>
 <concept_significance>500</concept_significance>
 <concept>
 <concept_id>10011007.10011006.10011072</concept_id>
 <concept_desc>Software and its engineering~Software libraries and repositories</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Runtime environments}
\ccsdesc[500]{Software and its engineering~Compilers}
\ccsdesc[300]{Software and its engineering~Software libraries and repositories}

\keywords{Benchmark, Repository, Synthesis, Training}  %% \keywords is optional

\maketitle

%\renewcommand{\shortauthors}{Marcos Siraichi, Vin\'{i}cius Santos,
%Sylvain Collange, Fernando Pereira}

\section{Introduction}
\label{sec:intro}

\fer{Context: explain what is access policies; where they are used; add at least five references.}
% References of access policies: YaPPL (for IoT), 

Access policies are a set of rules whose a system uses to allow or deny some
operation.
Immutable rules can also be called static access policies, as login routine,
where the rule is having the tuple $(username, password)$ stored in a database.
But there are systems that need dynamic access policies, in which there is a
way to specify and change such rules.
An example of this case, is the IoT applications which demand a ser of policies
to allow or deny a resource of getting information from a sensor in the network.
For that example, YaPPL\cite{} can be a solution, since it makes possible to
specify different policies in a specific JSON format.
This language defines a set of keyword to map a \textit{rule} for an
\textit{utilizer} with a \textit{purpose} that get some information by a
\textit{transformation}.
Due to the limited quantity of keywords, the power of that language is also
limited, although it specifies policies dynamically.

The problem of limited attributes also occurs with others access policy
languages, like [...], [...].
However, [...] uses the declaration of attributes with primitive data types,
giving more flexibility at the access policies.
Then, still about IoT systems, if another application demands a rule checking
according to the network address, further than YaPPL's attributes, it can be
done by the data declaration of [..a linguagem que to falando aqui..].


% Dar um outro exemplo de linguagem que também possui a limitação de não possuir
% uma declaração dos dados utilizados.

% A linguagem (que eu estudei uma vez e esqueci o nome) permite o uso de tipos
% primitivos de dados, e isso gera maior flexibilidade, assim como Hapi


% This paper is focused in this second class, by introducing a DSL
% (\textit{Domain Specific Language}) capable of expressing a set of rules and
% delivery them for a system in a useful structure.

\fer{Problem: explain why hierarchical access is important. Explain that exists legalease, but that is has never been fully defined.}

\fer{Solution: introduce our implementation of Hapi.}

\fer{Results: describe the toosl that we currently have.}

\section{Examples}
\label{sec:examples}

\fer{We need two or three examples that illustrate how Hapi is cool!}

\fer{We need at least one example that illustrates how Legalease is poorly defined.}

\section{Language Specification}
\label{sec:spec}

\subsection{Syntax}
\label{sub:syntax}

\subsection{Semantics}
\label{sub:semantics}
Before showing the policy evaluation, we need to understand the Access Entity
concept.
An Access Entity $AE$ is a set of labeled attributes, where each label is
unique.
Then we can imagine it as a C++ map, or a JSON for instance, which each label
is a string.
All \texttt{data} statements must have a corresponding label within $AE$ where
according to this link we shall define if an Access Entity is allowed or
denied.
For that decision, a Hapi policy can be viewed as list of tuples, representing
the allowed access entities.
The tuple size is the same of the number of \texttt{data} statements, since
each element in a tuple represents a value of the declared data.
Finally, a tuple is an access key where whatever $AE$ that satisfies all
elements inside this key, can pass through the policy.

To illustrate a real scenario, suppose a global system for university students.
A part of that system is exclusive only for USA students in the Economy course.
A short policy example, can be:
% data University: USA(MIT, UCLA), JAPAN(TokyoUniversity), MIT, UCLA, TokyoUniversity;
% data Course: Technologies(ComputerScience, Robotics), Finances(Accounting, Economy),
%              ComputerScience, Robotics, Accounting, Economy;

% main = 
% DENY
% EXCEPT {
%   ALLOW {
%     University: USA;
%     Course: Economy;
%   }
% };

This policy means the following tuple list
\texttt{[(MIT, Economy), (UCLA, Economy)]}, and according to that policy, an
allowed access entity might be \texttt{\{"Name": "Carolina", "University":
"MIT", "Course": "Economy"\}}.
Observe that the labeled attribute \texttt{name} is ignored, since it is not
considered in the Hapi policy, despite this, \texttt{Carolina}'s access entity
complies with \texttt{Economy} and \texttt{USA}.
In the same case, other entity as \texttt{\{"Name": "Bernard", "University":
"MIT", "Course": "ComputerScience"\}} cannot access, once this does not meet
Economy course.

% @TODO: explicar a idéia (em alto nível) de como a tupla foi gerada: 
%  - primeiro uma política negado por padrão
%  - depois uma exceção que gerou o allow para os dados informados.

In the section \ref{sub:parser} we will show our \textit{Intermediary
Relationship} -- IR --, that allows us to manipulate the policy information.
Using the IR we can easily generate the tuples list, since these two structures are
equivalent each other.
For now, we just assume the existence of the IR as a directed graph were
the edge \texttt{Attribute1} $\rightarrow$ \texttt{Attribute2} represents that
the two attributes are in the same tuple.
Inside the IR graph, we have two node types: \texttt{NonTerminal} as the
intermediary node type and \texttt{Terminal} as the leaves.

% def get_tuples_from(current_node, tuple):
%   tuple.add(current_node.value)
%   if current_node is Terminal:
%     return [tuple]
%   else:
%     l = []
%     l = l + get_tuples_from(current_node.next, tuple)
%     return l

% def tuples_list(IR):
%   l = []
%   for start_node in IR:
%     l = l + get_tuples_from(start_node, ())
%   return l

\section{Tools}
\label{sec:tools}

\subsection{Parser and Translators}
\label{sub:parser}

\subsection{The Graphical User Interface}
\label{sub:gui}

\section{Related Work}
\label{sec:rw}

\section{Conclusion}
\label{sec:conc}

\bibliography{references}

\end{document}
